<html>
<head>

<style>
p {color : black; font-family:courier; font-size: 80%;}
body {line-height: 100%; font-family:courier;}
.tlc_func {color : blue; font-weight: bold; font-size:120%;}
.tlc_if {color: green;}.tlc_assign {color: green;}.tlc_each {color: green;}.tlc_foreach {color: green;}.tlc_endif {color: green;}.tlc_switch {color: green;}.tlc_case {color: green;}.tlc_return {color: green;}.tlc_elseif {color: green;}.tlc_else {color: green;}.tlc_assert {color: green;}.tlc_function {color: green;}.tlc_endfunction {color: green;}.tlc_generatefile {color: green;}.tlc_includepath {color: green;}.tlc_include {color: green;}.tlc_sprintf {color: green;}.tlc_while {color: green;}.tlc_endwhile {color: green;}.tlc_default {color: green;}.tlc_createrecord {color: green;}.tlc_mergerecord {color: green;}.tlc_language {color: green;}.tlc_roll {color: green;}.tlc_endroll {color: green;}.tlc_with {color: green;}
.tlc_bifunc {color: brown;}
</style>

</head>
<body>
%%   <a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html">amdxfpgareadwrite.tlc</a> - TLC file for reading data from FPGA
 <br>%%
 <br>%%   Copyright 2012 The MathWorks, Inc.
 <br>&nbsp; <br><span class="tlc_implements">%implements</span> amdxfpgareadwrite "C"
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="Start" class="tlc_func">Start</a>(block, system) Output
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;uint8_T *baseaddr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;uint8_T *plxaddr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;uint32_T dmabuffer;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> deviceindex = block.SFcnParamSettings.DeviceIndex
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> num_ns_write = block.SFcnParamSettings.NumNSWrite
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_write_lth = block.SFcnParamSettings.NSWriteLth
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> s_write_off = block.SFcnParamSettings.SWriteOff
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> num_s_write = block.SFcnParamSettings.NumSWrite
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_s_write_lth = block.SFcnParamSettings.SWriteLth
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> write_strobe = block.SFcnParamSettings.WriteStrobe
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> num_ns_read = block.SFcnParamSettings.NumNSRead
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_read_lth = block.SFcnParamSettings.NSReadLth
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> s_read_off = block.SFcnParamSettings.SReadOff
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> num_s_read = block.SFcnParamSettings.NumSRead
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_s_read_lth = block.SFcnParamSettings.SReadLth
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> read_strobe = block.SFcnParamSettings.ReadStrobe
 <br>&nbsp; <br>%% PWORK variable names
 <br>%% PLX 
 <br>%% NSWrite 
 <br>%% SWrite 
 <br>%% W_STROBE 
 <br>%% W_DMA 
 <br>%% NSRead 
 <br>%% SRead 
 <br>%% R_STROBE 
 <br>%% R_DMA
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;baseaddr = (uint8_T *)xPCFpgaGetAddress( %&lt;deviceindex&gt;, 2 );
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( NSWrite, "", "", 0)> = (void *)(baseaddr);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( SWrite, "", "", 0)> = (void *)(baseaddr + %&lt;s_write_off&gt;);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( NSRead, "", "", 0)> = (void *)(baseaddr);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( SRead, "", "", 0)> = (void *)(baseaddr + %&lt;s_read_off&gt;);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;plxaddr = (uint8_T *)xPCFpgaGetAddress( %&lt;deviceindex&gt;, 0 ) + 0x80;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( PLX, "", "", 0)> = (void *)plxaddr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> write_strobe != 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( W_STROBE, "", "", 0)> = (void *)(baseaddr + %&lt;write_strobe&gt;);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( W_STROBE, "", "", 0)> = (void *)0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> read_strobe != 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( R_STROBE, "", "", 0)> = (void *)(baseaddr + %&lt;read_strobe&gt;);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( R_STROBE, "", "", 0)> = (void *)0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> mode = block.SFcnParamSettings.Mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> mode == 3 %% delayed coprocessor mode, don't wait for done the first time
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockIWork">LibBlockIWork</a>(FIRSTTIME,"","",0)&gt; = 1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockIWork">LibBlockIWork</a>(FIRSTTIME,"","",0)&gt; = 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%% Allocate enough DMA space for the full size of the data as uint32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% elements.  When we pack data, we'll just use part of it.
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%% 4 different data sets.  
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% non-streaming write
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% streaming write
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% Allocate one write buffer that's sized for the maximum of NS and S buffer
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> nsLength = 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> n = num_ns_write
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> nsLength = nsLength + p_ns_write_lth[n]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> sLength = 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> n = num_s_write
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> sLength = sLength + p_s_write_lth[n]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> length = nsLength
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> sLength > nsLength
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> length = sLength
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;dmabuffer = (int32_T)xpcAllocPhysicalMemory( (uint32_T)(4 * %&lt;length&gt;) );
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( W_DMA, "", "", 0)> = (void *)dmabuffer;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%% non-streaming read
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% streaming read
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% Allocate one read buffer that's sized for the maximum of NS and S buffer
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> nsLength = 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> n = num_ns_read
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> nsLength = nsLength + p_ns_read_lth[n]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> sLength = 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> n = num_s_read
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> sLength = sLength + p_s_read_lth[n]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> length = nsLength
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> sLength > nsLength
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> length = sLength
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;dmabuffer = (int32_T)xpcAllocPhysicalMemory( (uint32_T)(4 * %&lt;length&gt;) );
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>( R_DMA, "", "", 0)> = (void *)dmabuffer;
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br>%% Function: BlockTypeSetup ===============================================
 <br>%%
 <br><span class="tlc_function">%function</span> <a id="BlockTypeSetup" class="tlc_func">BlockTypeSetup</a>(block, system) void
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cachelib.html#LibAddToCommonIncludes">LibAddToCommonIncludes</a>("xpctarget.h")&gt;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cachelib.html#LibAddToCommonIncludes">LibAddToCommonIncludes</a>("amdxfpgautil.h")&gt;
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="Outputs" class="tlc_func">Outputs</a>(block, system) Output
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> mode = block.SFcnParamSettings.Mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_switch">%switch</span> mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Free running mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// assert read strobe, Read old results, write new data, write strobe
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// No check for done.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Not direct feedthrough, do write and strobe in mdlUpdate
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAReadStrobe">xpcFPGAReadStrobe</a>( block )>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAReadNS">xpcFPGAReadNS</a>( block )>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteNS">xpcFPGAWriteNS</a>( block )>  %% moved to Update
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteStrobe">xpcFPGAWriteStrobe</a>( block )>  %% moved to Update
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 2
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Blocking Coprocessor mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Write data, poll for done, read results
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Direct feedthrough, do everything here in Outputs
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteNS">xpcFPGAWriteNS</a>( block )>      %% new parameters
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAStartSWrite">xpcFPGAStartSWrite</a>( block )>  %% streaming write, copy inports, start DMA0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAStartSRead">xpcFPGAStartSRead</a>( block )>   %% streaming read, start DMA1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteStrobe">xpcFPGAWriteStrobe</a>( block )>  %% start cycle
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWaitDone">xpcFPGAWaitDone</a>( block )>     %% wait for result
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAReadS">xpcFPGAReadS</a>( block )>        %% copy streaming DMA buffer to outport
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAReadNS">xpcFPGAReadNS</a>( block )>       %% result ns to outports
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 3
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Delayed Coprocessor mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Check for done, read old results, write new data
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Don't check done on the first iteration after start.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Not direct feedthrough, do write and strobe in mdlUpdate
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWaitDone">xpcFPGAWaitDone</a>( block )>     %% wait for previous result
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAReadS">xpcFPGAReadS</a>( block )>        %% copy streaming buffer to outports
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAReadNS">xpcFPGAReadNS</a>( block )>       %% previous result ns to outports
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteNS">xpcFPGAWriteNS</a>( block )>      %% new parameters, in Update
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAStartSWrite">xpcFPGAStartSWrite</a>( block )>  %% streaming write, copy inports, start DMA, in Update
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAStartSRead">xpcFPGAStartSRead</a>( block )>   %% streaming read, start DMA
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteStrobe">xpcFPGAWriteStrobe</a>( block )>  %% start cycle, in Update
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endswitch">%endswitch</span>
 <br>}
 <br>%%return
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="Update" class="tlc_func">Update</a>(block, system) Output
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> mode = block.SFcnParamSettings.Mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_switch">%switch</span> mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Free running mode
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// assert read strobe, Read old results, write new data, write strobe
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// No check for done.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Not direct feedthrough
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteNS">xpcFPGAWriteNS</a>( block )>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteStrobe">xpcFPGAWriteStrobe</a>( block )>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 2
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// All the work is in outputs
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 3
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Not direct feedthrough, setup and perform reads in Update
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteNS">xpcFPGAWriteNS</a>( block )>      %% new parameters
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAStartSWrite">xpcFPGAStartSWrite</a>( block )>  %% streaming write, copy inports, start DMA
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/toolbox/rtw/targets/xpc/target/build/xpcblocks/tlc_c/amdxfpgareadwrite.html#xpcFPGAWriteStrobe">xpcFPGAWriteStrobe</a>( block )>  %% start cycle
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endswitch">%endswitch</span>
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAWriteNS" class="tlc_func">xpcFPGAWriteNS</a>( block ) Output
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;// Write NS data and set up streaming DMA and strobe if mode is 2 or 3
 <br>&nbsp;&nbsp;&nbsp;&nbsp;// If mode is 1, no streaming data.  Write NS data and strobe.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> mode = block.SFcnParamSettings.Mode
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_write_off = block.SFcnParamSettings.NSWriteOff
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> num_ns_write = block.SFcnParamSettings.NumNSWrite
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_write_type = block.SFcnParamSettings.NSWriteType
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_write_lth = block.SFcnParamSettings.NSWriteLth
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> boardtype = block.SFcnParamSettings.boardType
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;int32_T bidx = 0;
 <br>&nbsp; <br>%% Loop through all the ports and write each vector to its own address
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> tidx = num_ns_write
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%% boardType == 1 uses the PLX DMA engine
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% boardType == 2 is the Spartan 6, simplified DMA engine
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> writeType = p_ns_write_type[tidx]
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> p_ns_write_lth[tidx] > 30 && boardtype == 1 %% size cutoff for DMA to be faster than DMA, PCI->FPGA
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile xPCFpgaPLX *plx = (xPCFpgaPLX *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(PLX,"","",0)&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_T ctr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_T *dmabuffer = (uint32_T *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(W_DMA,"","",0)&gt;;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pci address is the physical memory address
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma0pci   = (uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(W_DMA,"","",0)&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// local address is the offset into BAR2 space
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%% plx->dma0local = (uint32_T)(%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(NSWrite,"","",0)&gt;) + (uint32_T)%&lt;p_ns_write_off[tidx]&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma0local = (uint32_T)%&lt;p_ns_write_off[tidx]&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma0descriptor = 0x2;  // end of chain
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy the data to the DMA physical buffer
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Add unpacking here
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( ctr = 0 ; ctr < (uint32_T)%&lt;p_ns_write_lth[tidx]&gt; ; ctr++ )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dmabuffer[ctr] = ((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockInputSignalAddr">LibBlockInputSignalAddr</a>(tidx, "", "", 0)>)[ctr];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_switch">%switch</span> writeType
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 0 %% double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma0length = (int32_T)%&lt;p_ns_write_lth[tidx]&gt;*8;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 1 %% single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 6 %% int32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 7 %% uint32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// int32, uint32 or single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma0length = (int32_T)%&lt;p_ns_write_lth[tidx]&gt;*4;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endswitch">%endswitch</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma0mode = 0x143;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start the transfer and wait for completion
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma0cmdstatus = 0x0B;    // clear int, enable and start
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( ctr = 0 ; ctr < 10000 ; ctr++ )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( plx->dma0cmdstatus & 0x10 )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>%% tidx is the port number and index into ns lengths array
 <br>%% This loop must do any data packing if port type isn't 32 bit.
 <br>%% Need a source index and a destination index.
 <br>%% Source index starts at 0 for each port and goes up to that port's length
 <br>%% Destination index has to take into account packing and is cumulative.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_T iter = 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> p_ns_write_lth[tidx] > 1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( iter = 0 ; iter < %&lt;p_ns_write_lth[tidx]&gt; ; iter++ )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_switch">%switch</span> writeType
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 0 %% double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_T *)((uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(NSWrite,"","",0)&gt; + (uint32_T)%&lt;p_ns_write_off[tidx]&gt;))[2*iter] = ((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockInputSignalAddr">LibBlockInputSignalAddr</a>(tidx, "", "", 0)>)[2*iter];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_T *)((uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(NSWrite,"","",0)&gt; + (uint32_T)%&lt;p_ns_write_off[tidx]&gt;))[2*iter+1] = ((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockInputSignalAddr">LibBlockInputSignalAddr</a>(tidx, "", "", 0)>)[2*iter+1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 1 %% single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 6 %% int32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 7 %% uint32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// int32, uint32 or single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_T *)((uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(NSWrite,"","",0)&gt; + (uint32_T)%&lt;p_ns_write_off[tidx]&gt;))[iter] = ((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockInputSignalAddr">LibBlockInputSignalAddr</a>(tidx, "", "", 0)>)[iter];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endswitch">%endswitch</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> p_ns_write_lth[tidx] > 1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAWriteStrobe" class="tlc_func">xpcFPGAWriteStrobe</a>( block ) Output
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> strobe = block.SFcnParamSettings.WriteStrobe
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> strobe != 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Assert the write strobe if strobe address is non-zero
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile uint32_T dummy = 1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(uint32_T *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(W_STROBE,"","",0)&gt; = dummy;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAReadStrobe" class="tlc_func">xpcFPGAReadStrobe</a>( block ) Output
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> strobe = block.SFcnParamSettings.ReadStrobe
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> strobe != 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile uint32_T dummy = 1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*(uint32_T *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(R_STROBE,"","",0)&gt; = dummy;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAReadNS" class="tlc_func">xpcFPGAReadNS</a>( block ) Output
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% If mode is 1, assert read strobe then read NS data
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% If mode is 2, set up streaming DMA, poll for done, read NS data
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% If mode is 3, no streaming, but poll for done, read NS data
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> deviceindex = block.SFcnParamSettings.DeviceIndex
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> mode = block.SFcnParamSettings.Mode
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_read_off = block.SFcnParamSettings.NSReadOff
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> num_ns_read = block.SFcnParamSettings.NumNSRead
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_read_type = block.SFcnParamSettings.NSReadType
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_ns_read_lth = block.SFcnParamSettings.NSReadLth
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> s_read_off = block.SFcnParamSettings.SReadOff
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> num_s_read = block.SFcnParamSettings.NumSRead
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> p_s_read_lth = block.SFcnParamSettings.SReadLth
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> read_strobe = block.SFcnParamSettings.ReadStrobe
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> write_strobe = block.SFcnParamSettings.WriteStrobe
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> boardtype = block.SFcnParamSettings.boardType
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%% after we add packing, nsLength needs to be the number of packed
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% uint32's.  This will be less than this nsLength.
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> tidx = num_ns_read
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%% boardType == 1 uses the PLX DMA engine
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%% boardType == 2 is the Spartan 6, simplified DMA engine
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> readType = p_ns_read_type[tidx]
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> p_ns_read_lth[tidx] > 3 && boardtype == 1 %% size cutoff for DMA to be faster than PIO, FPGA->PCI
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;volatile xPCFpgaPLX *plx = (xPCFpgaPLX *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(PLX,"","",0)&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_T ctr;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pci address is the physical memory address
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma1pci   = (uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(R_DMA,"","",0)&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// local address is the offset into BAR2 space
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma1local = %&lt;p_ns_read_off[tidx]&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma1descriptor = 0xa;  // end of chain, local->pci (read)
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// All actual IO is via uint32 variables
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_switch">%switch</span> readType
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 0 %% double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma1length = (int32_T)%&lt;p_ns_read_lth[tidx]&gt;*8;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 1 %% single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 6 %% int32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 7 %% uint32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// int32, uint32 or single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma1length = (int32_T)%&lt;p_ns_read_lth[tidx]&gt;*4;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endswitch">%endswitch</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma1mode = 0x143;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Start the transfer and wait for completion
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;plx->dma1cmdstatus = 0x0B;    // clear int, enable and start
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( ctr = 0 ; ctr < 10000 ; ctr++ )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( plx->dma1cmdstatus & 0x10 )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy the data from dmabuffer to the signal
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%% for each port, move words for each port count to the appropriate out signal
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_T *dmabuffer = (uint32_T *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(R_DMA,"","",0)&gt;;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Copy the data from the DMA physical buffer
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( ctr = 0 ; ctr < (uint32_T)%&lt;p_ns_read_lth[tidx]&gt; ; ctr++ )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Do unpacking here
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockOutputSignalAddr">LibBlockOutputSignalAddr</a>(tidx, "", "", 0)>)[ctr] = dmabuffer[ctr];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint32_T iter = 0;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> %&lt;p_ns_read_lth[tidx]&gt; > 1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for( iter = 0 ; iter < %&lt;p_ns_read_lth[tidx]&gt; ; iter++ )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_switch">%switch</span> readType
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 0 %% double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// double
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockOutputSignalAddr">LibBlockOutputSignalAddr</a>(tidx, "", "", 0)>)[2*iter] = ((uint32_T *)((uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(NSRead,"","",0)&gt; + (uint32_T)%&lt;p_ns_read_off[tidx]&gt;))[2*iter];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockOutputSignalAddr">LibBlockOutputSignalAddr</a>(tidx, "", "", 0)>)[2*iter+1] = ((uint32_T *)((uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(NSRead,"","",0)&gt; + (uint32_T)%&lt;p_ns_read_off[tidx]&gt;))[2*iter+1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 1 %% single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 6 %% int32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_case">%case</span> 7 %% uint32
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// int32, uint32 or single
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;((uint32_T *)%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blkiolib.html#LibBlockOutputSignalAddr">LibBlockOutputSignalAddr</a>(tidx, "", "", 0)>)[iter] = ((uint32_T *)((uint32_T)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(NSRead,"","",0)&gt; + (uint32_T)%&lt;p_ns_read_off[tidx]&gt;))[iter];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_break">%break</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endswitch">%endswitch</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> %&lt;p_ns_read_lth[tidx]&gt; > 1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAStartSWrite" class="tlc_func">xpcFPGAStartSWrite</a>( block ) Output
 <br>{
 <br>// streaming write, copy inports, start DMA0
 <br>// Not supported yet
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAStartSRead" class="tlc_func">xpcFPGAStartSRead</a>( block ) Output
 <br>{
 <br>// streaming read, start DMA1
 <br>// Not supported yet
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAWaitDone" class="tlc_func">xpcFPGAWaitDone</a>( block ) Output
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> done = block.SFcnParamSettings.ReadStrobe
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> done != 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;int32_T cnt = 0;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;// wait for result, wait until var at ReadStrobe is 1
 <br>&nbsp;&nbsp;&nbsp;&nbsp;// Needs a timeout!  The PCI read takes about .75us, so 1e7 of them will be
 <br>&nbsp;&nbsp;&nbsp;&nbsp;// about 7.5 seconds.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if( %&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockIWork">LibBlockIWork</a>(FIRSTTIME,"","",0)&gt; == 1 )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>%%printf("First time, no wait/n");
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockIWork">LibBlockIWork</a>(FIRSTTIME,"","",0)&gt; = 0;  // Don't wait the first time through.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;else
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>%%printf("waiting/n");
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while( (*(volatile uint32_T *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(R_STROBE,"","",0)&gt; == 0) && cnt++ < 1e7 )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="xpcFPGAReadS" class="tlc_func">xpcFPGAReadS</a>( block ) Output
 <br>{
 <br>// copy streaming buffer to outport
 <br>// Not supported yet
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_function">%function</span> <a id="Terminate" class="tlc_func">Terminate</a>(block, system) Output
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;/*------------ %&lt;Type&gt; Block: %&lt;Name&gt; ------------*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;void *dmabuffer = (void *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(W_DMA,"","",0)&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if( dmabuffer != NULL )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xpcFreePhysicalMemory( dmabuffer );
 <br>&nbsp;&nbsp;&nbsp;&nbsp;dmabuffer = (void *)%&lt;<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(R_DMA,"","",0)&gt;;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if( dmabuffer != NULL )
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xpcFreePhysicalMemory( dmabuffer );
 <br>}
 <br><span class="tlc_endfunction">%endfunction</span>
 <br></body></html>