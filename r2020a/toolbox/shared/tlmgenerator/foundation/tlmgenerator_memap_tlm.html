<html>
<head>

<style>
p {
    color : black; font-family:courier; font-size: 80%;
}
body {
    line-height: 120%; font-family:courier; font-zize:60%;
}
.tlc_func {color : blue; font-weight: bold; font-size:120%;}
.tlc_comment {color : #9aa;}
.tlc_if {color: green;}.tlc_assign {color: green;}.tlc_each {color: green;}.tlc_foreach {color: green;}.tlc_endif {color: green;}.tlc_switch {color: green;}.tlc_case {color: green;}.tlc_return {color: green;}.tlc_elseif {color: green;}.tlc_else {color: green;}.tlc_assert {color: green;}.tlc_endwith {color: green;}.tlc_endforeach {color: green;}.tlc_generatefile {color: green;}.tlc_includepath {color: green;}.tlc_include {color: green;}.tlc_sprintf {color: green;}.tlc_while {color: green;}.tlc_endwhile {color: green;}.tlc_default {color: green;}.tlc_createrecord {color: green;}.tlc_mergerecord {color: green;}.tlc_language {color: green;}.tlc_roll {color: green;}.tlc_endroll {color: green;}.tlc_with {color: green;}.tlc_selectfile {color: green;}.tlc_openfile {color: green;}.tlc_closefile {color: green;}.tlc_def {color: green;}.tlc_undef {color: green;}.tlc_realformat {color: green;}.tlc_endswitch {color: green;}.tlc_addtorecord {color: green;}.tlc_break {color: green;}
.tlc_bifunc {color: brown;}
.tlc_fkw {color:blue; font-weight: 800;}
.tlc_output {color:#FFF; font-style:italic;}
.tlc_mchar {color:purple;}
</style>

</head>
<body>
<span class="tlc_comment">%%<span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span>Copyright<span style="padding-left:9.5px"></span>2009-2010<span style="padding-left:9.5px"></span>The<span style="padding-left:9.5px"></span>MathWorks,<span style="padding-left:9.5px"></span>Inc.
</span> <br>&nbsp; <br><span class="tlc_selectfile">%selectfile</span> NULL_FILE
 <br>&nbsp; <br><span class="tlc_include">%include</span> "tlmgenerator_flagreg%<<span>tlmg_config.tlmgExt</span>>.tlc"
 <br>&nbsp; <br><span class="tlc_comment">%%Memory<span style="padding-left:9.5px"></span>Map<span style="padding-left:9.5px"></span>Constant
</span> <br><span class="tlc_openfile">%openfile</span> tlmg_memap_buf_const
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.SockNum 
 <br>//========= %<tlmg_memap.SockList[loopId1].SockName> SOCKET =========
 <br>#define %<tlmg_memap.SockList[loopId1].SockName>_BUSWIDTH %<tlmg_memap.SockList[loopId1].BitWidth>
 <br><span class="tlc_foreach">%foreach</span> loopId2 = tlmg_memap.SockList[loopId1].BankNum
 <br>//========= %<tlmg_memap.SockList[loopId1].Bank[loopId2].Name> BANK =========
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasAddress
 <br>//Bank base address
 <br>#define %<tlmg_memap.SockList[loopId1].Bank[loopId2].AddrName>   %<tlmg_memap.SockList[loopId1].Bank[loopId2].AddrHexStr>
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasRegister
 <br>//========= REGISTERS =========
 <br>//Address of the registers
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br>#define %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].AddrName>   %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].AddrHexStr>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endif">%endif</span>
 <br>//========= DATA =========
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br>#define %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].DimName>    %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Dim>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br><span class="tlc_if">%if</span> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Dim> > 1
 <br>typedef %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Type>   %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>[%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].DimName>];
 <br><span class="tlc_else">%else</span>
 <br>typedef %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Type>   %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>;
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> !tlmg_memap.SockList[loopId1].HasRegister
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasInput
 <br>//Type of the input data
 <br>typedef struct
 <br>{
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br>&nbsp;&nbsp;%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>;
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>}%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>;
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasOutput
 <br>//Type of the output data
 <br>typedef struct
 <br>{
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br>&nbsp;&nbsp;%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>;
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>}%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>;
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasParam
 <br>//Type of the param data
 <br>typedef struct
 <br>{
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br>&nbsp;&nbsp;%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>;
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>}%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>;
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasTestSet
 <br>//========= %<tlmg_memap.SockList[loopId1].TestSetBank.Name> BANK =========
 <br>//Bank base address
 <br>#define %<tlmg_memap.SockList[loopId1].TestSetBank.AddrName>   %<tlmg_memap.SockList[loopId1].TestSetBank.AddrHexStr>
 <br>//Address of the test&amp;set register
 <br>#define %<tlmg_memap.SockList[loopId1].TestSetBank.Reg[0].AddrName> %<tlmg_memap.SockList[loopId1].TestSetBank.Reg[0].AddrHexStr>
 <br>typedef %<tlmg_memap.SockList[loopId1].TestSetBank.Reg[0].Type>   %<tlmg_memap.SockList[loopId1].TestSetBank.Reg[0].TypeName>;
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasComStat
 <br>//========= %<tlmg_memap.SockList[loopId1].ComStatBank.Name> BANK =========
 <br>//Bank base address
 <br>#define %<tlmg_memap.SockList[loopId1].ComStatBank.AddrName>   %<tlmg_memap.SockList[loopId1].ComStatBank.AddrHexStr>
 <br>//Address of the command&amp;status register
 <br>#define %<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].AddrName> %<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].AddrHexStr>
 <br>typedef %<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].Type>   %<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].TypeName>;
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId2 = tlmg_memap.SockList[loopId1].BankNum
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br><span class="tlc_if">%if</span> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum> > 0 
 <br>//========= BIT FIELDS =========
 <br><span class="tlc_break">%break</span>
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_break">%break</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId2 = tlmg_memap.SockList[loopId1].BankNum
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br><span class="tlc_if">%if</span> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum> > 0 
 <br>//Register %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name> bit fields
 <br><span class="tlc_foreach">%foreach</span> loopId4 = tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum
 <br>#define %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffsetName> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffset>
 <br>#define %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitWidthName> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitWidth>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br>//========= COMMAND/STATUS REGISTER BIT DEFINITION =========
 <br>&nbsp; <br>#define RESET_BIT_MASK      0x01  //bit 0 write only
 <br>#define START_BIT_MASK      0x02  //bit 1 write only
 <br>#define INT_STAT_BIT_MASK   0x04  //bit 2 read only
 <br>#define INT_DIS_BIT_MASK    0x08  //bit 3 read/write
 <br>#define RESERVED4_BIT_MASK  0x10  //bit 4 reserved
 <br>#define RESERVED5_BIT_MASK  0x20  //bit 5 reserved
 <br>#define RESERVED6_BIT_MASK  0x40  //bit 6 reserved
 <br>#define RESERVED7_BIT_MASK  0x80  //bit 7 reserved
 <br>&nbsp; <br>#define INPUT_PUSH_BIT_MASK 0x0100  //bit 8 write only
 <br>#define INPUT_AUTMOD_BIT_MASK 0x0200  //bit 9 read/write
 <br>#define RESERVED10_BIT_MASK 0x0400  //bit 10 reserved
 <br>#define RESERVED11_BIT_MASK 0x0800  //bit 11 reserved
 <br>#define OUTPUT_PULL_BIT_MASK 0x1000 //bit 12 write only
 <br>#define OUTPUT_AUTMOD_BIT_MASK 0x2000 //bit 13 read/write
 <br>#define RESERVED14_BIT_MASK 0x4000  //bit 14 reserved
 <br>#define RESERVED15_BIT_MASK 0x8000  //bit 15 reserved
 <br>&nbsp; <br>#define INBUF_EMPTY_BIT_MASK  0x010000  //bit 16 read only
 <br>#define INBUF_FULL_BIT_MASK   0x020000  //bit 17 read only
 <br>#define INBUF_UNFLW_BIT_MASK  0x040000  //bit 18 read/write
 <br>#define INBUF_OVFLW_BIT_MASK  0x080000  //bit 19 read/write
 <br>#define OUTBUF_EMPTY_BIT_MASK 0x100000  //bit 20 read only
 <br>#define OUTBUF_FULL_BIT_MASK  0x200000  //bit 21 read only
 <br>#define OUTBUF_UNFLW_BIT_MASK 0x400000  //bit 22 read/write
 <br>#define OUTBUF_OVFLW_BIT_MASK 0x800000  //bit 23 read/write
 <br>&nbsp; <br>#define RESERVED24_BIT_MASK 0x01000000  //bit 24 reserved
 <br>#define RESERVED25_BIT_MASK 0x02000000  //bit 25 reserved
 <br>#define RESERVED26_BIT_MASK 0x04000000  //bit 26 reserved
 <br>#define RESERVED27_BIT_MASK 0x08000000  //bit 27 reserved
 <br>#define RESERVED28_BIT_MASK 0x10000000  //bit 28 reserved
 <br>#define RESERVED29_BIT_MASK 0x20000000  //bit 29 reserved
 <br>#define RESERVED30_BIT_MASK 0x40000000  //bit 30 reserved
 <br>#define RESERVED31_BIT_MASK 0x80000000  //bit 31 reserved
 <br>&nbsp; <br>#define WRITEONLY_BIT_MASK (RESET_BIT_MASK | START_BIT_MASK | INPUT_PUSH_BIT_MASK | OUTPUT_PULL_BIT_MASK)
 <br>#define READONLY_BIT_MASK (INT_STAT_BIT_MASK | INBUF_EMPTY_BIT_MASK | INBUF_FULL_BIT_MASK | OUTBUF_EMPTY_BIT_MASK | OUTBUF_FULL_BIT_MASK)
 <br>&nbsp; <br><span class="tlc_closefile">%closefile</span> tlmg_memap_buf_const
 <br>&nbsp; <br><span class="tlc_comment">%%Public<span style="padding-left:9.5px"></span>Declaration
</span> <br><span class="tlc_openfile">%openfile</span> tlmg_memap_public_decl
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.SockNum 
 <br>tlm_utils::simple_target_socket<%<<span>tlmname</span>>,%<tlmg_memap.SockList[loopId1].SockName>_BUSWIDTH>  %<tlmg_memap.SockList[loopId1].SockName>;
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.PortNum 
 <br><span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].WriteAccess
 <br><span class="tlc_if">%if</span> %<tlmg_memap.PortList[loopId1].Dim> > 1
 <br>sc_in<%<tlmg_memap.PortList[loopId1].Type>[%<tlmg_memap.PortList[loopId1].Dim>]> %<tlmg_memap.PortList[loopId1].PortName>;
 <br><span class="tlc_else">%else</span>
 <br>sc_in<%<tlmg_memap.PortList[loopId1].Type>> %<tlmg_memap.PortList[loopId1].PortName>;
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endif">%endif</span> 
 <br><span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].ReadAccess
 <br><span class="tlc_if">%if</span> %<tlmg_memap.PortList[loopId1].Dim> > 1
 <br>sc_out<%<tlmg_memap.PortList[loopId1].Type>[%<tlmg_memap.PortList[loopId1].Dim>]> %<tlmg_memap.PortList[loopId1].PortName>;
 <br><span class="tlc_else">%else</span>
 <br>sc_out<%<tlmg_memap.PortList[loopId1].Type>> %<tlmg_memap.PortList[loopId1].PortName>;
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> %<<span>tlmg_info.ParamStruct.NumPorts</span>> > 0
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId = tlmg_info.ParamStruct.NumPorts 
 <br>&nbsp; <br><span class="tlc_if">%if</span> %<tlmg_info.ParamStruct.Port[loopId].Dim> > 1
 <br>typedef %<tlmg_info.ParamStruct.Port[loopId].DataType>[%<tlmg_info.ParamStruct.Port[loopId].Dim>] %<tlmg_info.ParamStruct.Port[loopId].Name>_T;
 <br><span class="tlc_else">%else</span>
 <br>typedef %<tlmg_info.ParamStruct.Port[loopId].DataType> %<tlmg_info.ParamStruct.Port[loopId].Name>_T;
 <br><span class="tlc_endif">%endif</span>
 <br>void SetParam_%<tlmg_info.ParamStruct.Port[loopId].Name>(const %<tlmg_info.ParamStruct.Port[loopId].Name>_T* p_%<tlmg_info.ParamStruct.Port[loopId].Name>);
 <br>void GetParam_%<tlmg_info.ParamStruct.Port[loopId].Name>(%<tlmg_info.ParamStruct.Port[loopId].Name>_T* p_%<tlmg_info.ParamStruct.Port[loopId].Name>);
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_closefile">%closefile</span> tlmg_memap_public_decl
 <br>&nbsp; <br><span class="tlc_comment">%%Memory<span style="padding-left:9.5px"></span>Map<span style="padding-left:9.5px"></span>Declaration
</span> <br><span class="tlc_openfile">%openfile</span> tlmg_memap_private_decl
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId = tlmg_memap.SockNum 
 <br>void entry_b_transport_%<tlmg_memap.SockList[loopId].Name> (tlm::tlm_generic_payload &amp;gp, sc_core::sc_time &amp;delay_time);
 <br>unsigned int entry_transport_%<tlmg_memap.SockList[loopId].Name>_dbg (tlm::tlm_generic_payload &amp;gp);
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.PortNum 
 <br><span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].WriteAccess
 <br>void %<tlmg_memap.PortList[loopId1].PortName>_cb(void);
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_closefile">%closefile</span> tlmg_memap_private_decl
 <br>&nbsp; <br><span class="tlc_openfile">%openfile</span> tlmg_memap_public_ctor
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId = tlmg_memap.SockNum 
 <br>%<tlmg_memap.SockList[loopId].SockName>("%<tlmg_memap.SockList[loopId].Name>"),
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_closefile">%closefile</span> tlmg_memap_public_ctor
 <br>&nbsp; <br><span class="tlc_openfile">%openfile</span> tlmg_memap_private_ctor
 <br><span class="tlc_closefile">%closefile</span> tlmg_memap_private_ctor
 <br>&nbsp; <br><span class="tlc_comment">%%Memory<span style="padding-left:9.5px"></span>Map<span style="padding-left:9.5px"></span>Initialization
</span> <br><span class="tlc_openfile">%openfile</span> tlmg_memap_init
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId = tlmg_memap.SockNum 
 <br>%<tlmg_memap.SockList[loopId].SockName>.register_b_transport(this, &amp;%<<span>tlmname</span>>::entry_b_transport_%<tlmg_memap.SockList[loopId].Name>);
 <br>%<tlmg_memap.SockList[loopId].SockName>.register_transport_dbg(this, &amp;%<<span>tlmname</span>>::entry_transport_%<tlmg_memap.SockList[loopId].Name>_dbg);
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.PortNum 
 <br><span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].WriteAccess
 <br>SC_METHOD(%<tlmg_memap.PortList[loopId1].PortName>_cb);
 <br>dont_initialize();
 <br>sensitive << %<tlmg_memap.PortList[loopId1].PortName>;
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_closefile">%closefile</span> tlmg_memap_init
 <br>&nbsp; <br>&nbsp; <br><span class="tlc_comment">%%Memory<span style="padding-left:9.5px"></span>Map<span style="padding-left:9.5px"></span>Implementation
</span> <br><span class="tlc_openfile">%openfile</span> tlmg_memap_impl
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.SockNum 
 <br>//==============================================================================
 <br>//  b_transport implementation for %<tlmg_memap.SockList[loopId1].SockName>
 <br>//
 <br>//=============================================================================
 <br>void %<<span>tlmname</span>>::entry_b_transport_%<tlmg_memap.SockList[loopId1].Name> (tlm::tlm_generic_payload &amp;gp, sc_core::sc_time &amp;delay_time)
 <br>{
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasAddress
 <br>&nbsp;&nbsp;&nbsp;&nbsp;sc_dt::uint64    address   = gp.get_address();     // memory address
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;tlm::tlm_command command   = gp.get_command();     // memory command
 <br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned char    *data     = gp.get_data_ptr();    // data pointer
 <br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned  int     length   = gp.get_data_length(); // data length
 <br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned long   timefactor =  ((length+(%<tlmg_memap.SockList[loopId1].SockName>_BUSWIDTH/8)-1)/(%<tlmg_memap.SockList[loopId1].SockName>_BUSWIDTH/8))-1;
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasRegister
 <br><span class="tlc_foreach">%foreach</span> loopId2 = tlmg_memap.SockList[loopId1].BankNum
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br>&nbsp;&nbsp;if(address == %<tlmg_memap.SockList[loopId1].Bank[loopId2].AddrName> + %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].AddrName>)
 <br>&nbsp;&nbsp;{
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].ReadAccess
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_trigint.notify(m_ack,delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum> > 0 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId4 = tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T* data64 = (uint64_T*)&amp;data[%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset>];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T field =0; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T mask = ~0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;field,&amp;m_output_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.OutputName>,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;field,&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.ParamName>,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = mask >> (64 - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitWidthName>); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = field &amp; mask;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = field << (%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffsetName> - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset> * 8);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = mask << (%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffsetName> - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset> * 8); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*data64 = *data64 &amp; ~mask; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*data64 = *data64 | field;   
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_output_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.OutputName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentReadsInBurstTimeData()*timefactor+m_FirstReadTimeData());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentReadsInBurstTimeCtrl()*timefactor+m_FirstReadTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].WriteAccess
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_WRITE_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentWritesInBurstTimeData()*timefactor+m_FirstWriteTimeData());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentWritesInBurstTimeCtrl()*timefactor+m_FirstWriteTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum> > 0 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId4 = tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T data64 = *(uint64_T*)&amp;data[%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset>];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T field = 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T mask = ~0;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = mask >> (64 - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitWidthName>); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data64 = data64 >> (%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffsetName> - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset> * 8);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = data64 &amp; mask;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsSignExt
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = ~(mask >> 1);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(field &amp; mask)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = field | mask; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_input_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.InputName>,&amp;field,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_input_refresh_reg.set(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.InputPos>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.ParamName>,&amp;field,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_input_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.InputName>,data,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_input_refresh_reg.set(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.InputPos>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,data,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Auto-buffer
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(m_input_refresh_reg.test())
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_input_refresh_reg.init(false);
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(m_comstat_reg &amp; INPUT_AUTMOD_BIT_MASK)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span>tlmg_process_trigger</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>}
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> !tlmg_memap.SockList[loopId1].HasRegister
 <br><span class="tlc_foreach">%foreach</span> loopId2 = tlmg_memap.SockList[loopId1].BankNum
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasAddress
 <br>&nbsp;&nbsp;if(address == %<tlmg_memap.SockList[loopId1].Bank[loopId2].AddrName>)
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;{
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasOutput || tlmg_memap.SockList[loopId1].Bank[loopId2].HasParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_trigint.notify(m_ack,delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum   
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,&amp;m_output_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.OutputName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentReadsInBurstTimeData()*timefactor+m_FirstReadTimeData());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentReadsInBurstTimeCtrl()*timefactor+m_FirstReadTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasInput || tlmg_memap.SockList[loopId1].Bank[loopId2].HasParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_WRITE_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentWritesInBurstTimeData()*timefactor+m_FirstWriteTimeData());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentWritesInBurstTimeCtrl()*timefactor+m_FirstWriteTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum   
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_input_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.InputName>,&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_input_refresh_reg.set(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.InputPos>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//Auto-buffer
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(m_input_refresh_reg.test())
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_input_refresh_reg.init(false);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(m_comstat_reg &amp; INPUT_AUTMOD_BIT_MASK)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span>tlmg_process_trigger</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;}
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasTestSet
 <br>&nbsp;&nbsp;if(address == %<tlmg_memap.SockList[loopId1].TestSetBank.AddrName> + %<tlmg_memap.SockList[loopId1].TestSetBank.Reg[0].AddrName>)
 <br>&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(m_testset_reg)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_testset_reg,sizeof(m_testset_reg));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_testset_reg = 1;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentReadsInBurstTimeCtrl()*timefactor+m_FirstReadTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_WRITE_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentWritesInBurstTimeCtrl()*timefactor+m_FirstWriteTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_testset_reg = 0;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasComStat
 <br>&nbsp;&nbsp;if(address == %<tlmg_memap.SockList[loopId1].ComStatBank.AddrName> + %<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].AddrName>)
 <br>&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(m_comstat_reg)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_comstat_reg,sizeof(m_comstat_reg));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentReadsInBurstTimeCtrl()*timefactor+m_FirstReadTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_WRITE_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time += AssertDelay(m_SubsequentWritesInBurstTimeCtrl()*timefactor+m_FirstWriteTimeCtrl());
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait(delay_time);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(*((%<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].TypeName> *)data))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case RESET_BIT_MASK:
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span>tlmg_info.InitializeFcn.Name</span>>(%<<span>tlmg_info.RTMStruct.Name</span>>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reg_init();
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case START_BIT_MASK:
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span>tlmg_process_trigger</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case INPUT_PUSH_BIT_MASK:
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span>tlmg_process_trigger</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case OUTPUT_PULL_BIT_MASK:
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;default:
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_comstat_reg = ((*(%<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].TypeName> *)data) &amp; ~(WRITEONLY_BIT_MASK | READONLY_BIT_MASK))|
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(m_comstat_reg &amp; (WRITEONLY_BIT_MASK | READONLY_BIT_MASK));
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;gp.set_response_status(tlm::TLM_COMMAND_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;return;
 <br>}
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.SockNum 
 <br>//==============================================================================
 <br>//  transport_dbg implementation for %<tlmg_memap.SockList[loopId1].SockName>
 <br>//
 <br>//=============================================================================
 <br>unsigned int %<<span>tlmname</span>>::entry_transport_%<tlmg_memap.SockList[loopId1].Name>_dbg (tlm::tlm_generic_payload &amp;gp)
 <br>{
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasAddress
 <br>&nbsp;&nbsp;&nbsp;&nbsp;sc_dt::uint64    address   = gp.get_address();     // memory address
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;tlm::tlm_command command   = gp.get_command();     // memory command
 <br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned char    *data     = gp.get_data_ptr();    // data pointer
 <br>&nbsp;&nbsp;&nbsp;&nbsp;unsigned  int     length   = gp.get_data_length(); // data length
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasRegister
 <br><span class="tlc_foreach">%foreach</span> loopId2 = tlmg_memap.SockList[loopId1].BankNum
 <br><span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum 
 <br>&nbsp;&nbsp;if(address == %<tlmg_memap.SockList[loopId1].Bank[loopId2].AddrName> + %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].AddrName>)
 <br>&nbsp;&nbsp;{
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].ReadAccess
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum> > 0 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId4 = tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T* data64 = (uint64_T*)&amp;data[%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset>];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T field =0; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T mask = ~0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;field,&amp;m_output_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.OutputName>,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;field,&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.ParamName>,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = mask >> (64 - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitWidthName>); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = field &amp; mask;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = field << (%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffsetName> - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset> * 8);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = mask << (%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffsetName> - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset> * 8); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*data64 = *data64 &amp; ~mask; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*data64 = *data64 | field;   
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_output_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.OutputName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return length;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].WriteAccess
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_WRITE_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum> > 0 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId4 = tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitFieldNum
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T data64 = *(uint64_T*)&amp;data[%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset>];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T field = 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uint64_T mask = ~0;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = mask >> (64 - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitWidthName>); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data64 = data64 >> (%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].BitOffsetName> - %<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteOffset> * 8);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = data64 &amp; mask;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsSignExt
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mask = ~(mask >> 1);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(field &amp; mask)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;field = field | mask; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_input_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.InputName>,&amp;field,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].MW.ParamName>,&amp;field,%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].BitField[loopId4].ByteDim>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_else">%else</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_input_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.InputName>,data,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,data,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return length;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>}
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> !tlmg_memap.SockList[loopId1].HasRegister
 <br><span class="tlc_foreach">%foreach</span> loopId2 = tlmg_memap.SockList[loopId1].BankNum
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasAddress
 <br>&nbsp;&nbsp;if(address == %<tlmg_memap.SockList[loopId1].Bank[loopId2].AddrName>)
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;{
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasOutput || tlmg_memap.SockList[loopId1].Bank[loopId2].HasParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum   
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsOutput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,&amp;m_output_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.OutputName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return length;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].HasInput || tlmg_memap.SockList[loopId1].Bank[loopId2].HasParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_WRITE_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> loopId3 = tlmg_memap.SockList[loopId1].Bank[loopId2].RegNum   
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_input_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.InputName>,&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_param_reg.%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].MW.ParamName>,&amp;((%<tlmg_memap.SockList[loopId1].Bank[loopId2].TypeName>*)data)->%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].Name>,sizeof(%<tlmg_memap.SockList[loopId1].Bank[loopId2].Reg[loopId3].TypeName>));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return length;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;}
 <br><span class="tlc_endforeach">%endforeach</span>
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasTestSet
 <br>&nbsp;&nbsp;if(address == %<tlmg_memap.SockList[loopId1].TestSetBank.AddrName> + %<tlmg_memap.SockList[loopId1].TestSetBank.Reg[0].AddrName>)
 <br>&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(m_testset_reg)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_testset_reg,sizeof(m_testset_reg));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return length;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br><span class="tlc_if">%if</span> tlmg_memap.SockList[loopId1].HasComStat
 <br>&nbsp;if(address == %<tlmg_memap.SockList[loopId1].ComStatBank.AddrName> + %<tlmg_memap.SockList[loopId1].ComStatBank.Reg[0].AddrName>)
 <br>&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if (length != sizeof(m_comstat_reg)) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_GENERIC_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if(command == tlm::TLM_READ_COMMAND)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memcpy(data,&amp;m_comstat_reg,sizeof(m_comstat_reg));
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gp.set_response_status(tlm::TLM_OK_RESPONSE);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return length;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;}
 <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;gp.set_response_status(tlm::TLM_COMMAND_ERROR_RESPONSE);
 <br>&nbsp;&nbsp;return 0;
 <br>}
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br><span class="tlc_foreach">%foreach</span> loopId1 = tlmg_memap.PortNum 
 <br><span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].WriteAccess
 <br>void %<<span>tlmname</span>>::%<tlmg_memap.PortList[loopId1].PortName>_cb(void)
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;m_input_reg.%<tlmg_memap.PortList[loopId1].MW.InputName> = %<tlmg_memap.PortList[loopId1].PortName>.read();
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].IsParam
 <br>&nbsp;&nbsp;&nbsp;&nbsp;m_param_reg.%<tlmg_memap.PortList[loopId1].MW.ParamName> = %<tlmg_memap.PortList[loopId1].PortName>.read();
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> tlmg_memap.PortList[loopId1].IsInput
 <br>&nbsp;&nbsp;&nbsp;&nbsp;//Auto-buffer
 <br>&nbsp;&nbsp;&nbsp;&nbsp;m_input_refresh_reg.set(%<tlmg_memap.PortList[loopId1].MW.InputPos>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;if (m_input_refresh_reg.test()) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m_input_refresh_reg.init(false);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (m_comstat_reg &amp; INPUT_AUTMOD_BIT_MASK) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sc_core::sc_time delay_time = sc_core::SC_ZERO_TIME;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span>tlmg_process_trigger</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>}
 <br><span class="tlc_endif">%endif</span>
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp; <br>&nbsp; <br><span class="tlc_if">%if</span> %<<span>tlmg_info.ParamStruct.NumPorts</span>> > 0
 <br><span class="tlc_foreach">%foreach</span> loopId = tlmg_info.ParamStruct.NumPorts 
 <br>void %<<span>tlmname</span>>::SetParam_%<tlmg_info.ParamStruct.Port[loopId].Name>(const %<tlmg_info.ParamStruct.Port[loopId].Name>_T* param)
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;m_param_reg.%<tlmg_info.ParamStruct.Port[loopId].Name>,param,sizeof(%<tlmg_info.ParamStruct.Port[loopId].Name>_T));
 <br>}
 <br>&nbsp; <br>void %<<span>tlmname</span>>::GetParam_%<tlmg_info.ParamStruct.Port[loopId].Name>(%<tlmg_info.ParamStruct.Port[loopId].Name>_T* param)
 <br>{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(param,&amp;m_param_reg.%<tlmg_info.ParamStruct.Port[loopId].Name>,sizeof(%<tlmg_info.ParamStruct.Port[loopId].Name>_T));
 <br>}
 <br><span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp; <br><span class="tlc_closefile">%closefile</span> tlmg_memap_impl
 <br></body></html>