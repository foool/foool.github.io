<html>
<head>

<style>
p {
    color : black; font-family:courier; font-size: 80%;
}
body {
    line-height: 120%; font-family:courier; font-zize:60%;
}
.tlc_func {color : blue; font-weight: bold; font-size:120%;}
.tlc_comment {color : #9aa;}
.tlc_if {color: green;}.tlc_assign {color: green;}.tlc_each {color: green;}.tlc_foreach {color: green;}.tlc_endif {color: green;}.tlc_switch {color: green;}.tlc_case {color: green;}.tlc_return {color: green;}.tlc_elseif {color: green;}.tlc_else {color: green;}.tlc_assert {color: green;}.tlc_endwith {color: green;}.tlc_endforeach {color: green;}.tlc_generatefile {color: green;}.tlc_includepath {color: green;}.tlc_include {color: green;}.tlc_sprintf {color: green;}.tlc_while {color: green;}.tlc_endwhile {color: green;}.tlc_default {color: green;}.tlc_createrecord {color: green;}.tlc_mergerecord {color: green;}.tlc_language {color: green;}.tlc_roll {color: green;}.tlc_endroll {color: green;}.tlc_with {color: green;}.tlc_selectfile {color: green;}.tlc_openfile {color: green;}.tlc_closefile {color: green;}.tlc_def {color: green;}.tlc_undef {color: green;}.tlc_realformat {color: green;}.tlc_endswitch {color: green;}.tlc_addtorecord {color: green;}.tlc_break {color: green;}
.tlc_bifunc {color: brown;}
.tlc_fkw {color:blue; font-weight: 800;}
.tlc_output {color:#FFF; font-style:italic;}
.tlc_mchar {color:purple;}
</style>

</head>
<body>
<span class="tlc_comment">%%<span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span>
</span> <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Copyright<span style="padding-left:9.5px"></span>1994-2014<span style="padding-left:9.5px"></span>The<span style="padding-left:9.5px"></span>MathWorks,<span style="padding-left:9.5px"></span>Inc.
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Abstract:<span style="padding-left:9.5px"></span>Transport<span style="padding-left:9.5px"></span>Delay<span style="padding-left:9.5px"></span>block<span style="padding-left:9.5px"></span>helper<span style="padding-left:9.5px"></span>function<span style="padding-left:9.5px"></span>target<span style="padding-left:9.5px"></span>file
</span> <br>&nbsp; <br>&nbsp; <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Function:<span style="padding-left:9.5px"></span>TDelayTypeSetup<span style="padding-left:9.5px"></span>===============================================
</span> <br><span class="tlc_fkw">%function</span> <a id="TDelayTypeSetup" class="tlc_func">TDelayTypeSetup</a>(block, system) <span class="tlc_fkw">void</span>
 <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> !<span class="tlc_bifunc">EXISTS</span>("HasDelayBlock")
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> ::HasDelayBlock = TLC_FALSE
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp; <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> isRSim || Accelerator
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> tmpBuf 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> !HasDelayBlock
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifndef __RTW_UTFREE__
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern "C" {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#LibExternInFcnDecls">LibExternInFcnDecls</a>()</span>>void * utMalloc(size_t);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#LibExternInFcnDecls">LibExternInFcnDecls</a>()</span>>void   utFree(void *); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> ::HasDelayBlock= TLC_TRUE    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> tmpBuf
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cachelib.html#LibCacheExtern">LibCacheExtern</a>(tmpBuf)>
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br><span class="tlc_fkw">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Function:<span style="padding-left:9.5px"></span>TDelay_CreateBuf<span style="padding-left:9.5px"></span>============================================
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_fkw">%function</span> <a id="TDelay_CreateBuf" class="tlc_func">TDelay_CreateBuf</a>(block) <span class="tlc_fkw">void</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%% Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/fixpt/fixptlib.html#FixPt_UtilityMakeName">FixPt_UtilityMakeName</a>("rt_TDelayCreateBuf")
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%% END: Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Register utility name in the Shared Code Manager</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#SLibRegisterSharedUtility">SLibRegisterSharedUtility</a>(block, utilityName)
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% determine if the required utility has already been defined</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%   If it has not, then create the definition.</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> !(<span class="tlc_bifunc">ISFIELD</span>(FixPtUtils,utilityName))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% register that utility is being defined</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> tmpRet = <span class="tlc_bifunc">SETFIELD</span>(FixPtUtils,utilityName,1)
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPushEmptyStackSharedUtils">LibPushEmptyStackSharedUtils</a>()</span>>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> tmpBuf
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> (isRSim || Accelerator)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifndef __RTW_UTFREE__  <span class="tlc_comment">%% defined in rtw/c/src/rtw_modelmap.h   </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern "C" {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#LibExternInFcnDecls">LibExternInFcnDecls</a>()</span>>void * utMalloc(size_t);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> tmpBuf    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility header comments</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%  Produce header comment for utility</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> fcnAbstract 
 <br>Time delay buffer creation routine
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> fcnAbstract
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility definition</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% create first line of utility macro or function</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnName = "%<<span>utilityName</span>>"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnReturns = "void *"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnParams = ["int_T     numBuffer, ", "int_T     bufSz, ", "int_T     elemSz"]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcDecRoot    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>fcnReturns</span>> %<<span>fcnName</span>>(
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[0]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[1]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[2]>)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcDecRoot
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_createrecord">%createrecord</span> fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract fcnAbstract; Category "utility"; GeneratedBy "<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/blocks/tdelay_sup.html">tdelay_sup.tlc</a>"}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/mw/commonhdrlib.html#SLibDumpFunctionBanner">SLibDumpFunctionBanner</a>(fcnRec)>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_undef">%undef</span> fcnRec
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return((void*)utMalloc(numBuffer*bufSz*elemSz)); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish header comment</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish off utility define</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% cause utility define to be included in generated code</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityDef = tmpBuf + utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#SLibDumpUtilsSourceCodeAndCacheFunctionPrototype">SLibDumpUtilsSourceCodeAndCacheFunctionPrototype</a>(utilityName,funcProto,utilityDef)>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> GSUStackBuf = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPopStackSharedUtilsIncludes">LibPopStackSharedUtilsIncludes</a>()
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span>  <span class="tlc_comment">%% definition of utility</span>
 <br>&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/mathlib.html#FcnTrackSharedUtilHeaderFileUsage">FcnTrackSharedUtilHeaderFileUsage</a>(utilityName + ".h", TLC_FALSE)>
 <br>&nbsp;&nbsp;<span class="tlc_return">%return</span> utilityName
 <br><span class="tlc_fkw">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Function:<span style="padding-left:9.5px"></span>TDelay_FreeBuf<span style="padding-left:9.5px"></span>============================================
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_fkw">%function</span> <a id="TDelay_FreeBuf" class="tlc_func">TDelay_FreeBuf</a>(block) <span class="tlc_fkw">void</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%% Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/fixpt/fixptlib.html#FixPt_UtilityMakeName">FixPt_UtilityMakeName</a>("rt_TDelayFreeBuf")
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%% END: Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Register utility name in the Shared Code Manager</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#SLibRegisterSharedUtility">SLibRegisterSharedUtility</a>(block, utilityName)
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% determine if the required utility has already been defined</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%   If it has not, then create the definition.</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> !(<span class="tlc_bifunc">ISFIELD</span>(FixPtUtils,utilityName))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% register that utility is being defined</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> tmpRet = <span class="tlc_bifunc">SETFIELD</span>(FixPtUtils,utilityName,1)
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPushEmptyStackSharedUtils">LibPushEmptyStackSharedUtils</a>()</span>>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> tmpBuf
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> (isRSim || Accelerator)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifndef __RTW_UTFREE__  <span class="tlc_comment">%% defined in rtw/c/src/rtw_modelmap.h   </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern "C" {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#LibExternInFcnDecls">LibExternInFcnDecls</a>()</span>>void   utFree(void *); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> tmpBuf
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility header comments</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%  Produce header comment for utility</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> fcnAbstract 
 <br>Time delay buffer deletion routine
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> fcnAbstract
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility definition</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% create first line of utility macro or function</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnName = "%<<span>utilityName</span>>"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnReturns = "void"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnParams = ["void *     buf"]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcDecRoot    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>fcnReturns</span>> %<<span>fcnName</span>>(
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[0]>)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcDecRoot
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_createrecord">%createrecord</span> fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract fcnAbstract; Category "utility"; GeneratedBy "<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/blocks/tdelay_sup.html">tdelay_sup.tlc</a>"}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/mw/commonhdrlib.html#SLibDumpFunctionBanner">SLibDumpFunctionBanner</a>(fcnRec)>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_undef">%undef</span> fcnRec
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;utFree(buf); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish header comment</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish off utility define</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% cause utility define to be included in generated code</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityDef = tmpBuf + utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#SLibDumpUtilsSourceCodeAndCacheFunctionPrototype">SLibDumpUtilsSourceCodeAndCacheFunctionPrototype</a>(utilityName,funcProto,utilityDef)>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> GSUStackBuf = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPopStackSharedUtilsIncludes">LibPopStackSharedUtilsIncludes</a>()
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span>  <span class="tlc_comment">%% definition of utility</span>
 <br>&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/mathlib.html#FcnTrackSharedUtilHeaderFileUsage">FcnTrackSharedUtilHeaderFileUsage</a>(utilityName + ".h", TLC_FALSE)>
 <br>&nbsp;&nbsp;<span class="tlc_return">%return</span> utilityName
 <br><span class="tlc_fkw">%endfunction</span>
 <br>&nbsp; <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Function:<span style="padding-left:9.5px"></span>TDelay_Interpolate<span style="padding-left:9.5px"></span>==========================================
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_fkw">%function</span> <a id="TDelay_Interpolate" class="tlc_func">TDelay_Interpolate</a>(block) <span class="tlc_fkw">void</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/fixpt/fixptlib.html#FixPt_UtilityMakeName">FixPt_UtilityMakeName</a>("rt_TDelayInterpolate")
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%% END: Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Register utility name in the Shared Code Manager</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#SLibRegisterSharedUtility">SLibRegisterSharedUtility</a>(block, utilityName)
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% determine if the required utility has already been defined</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%   If it has not, then create the definition.</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> !(<span class="tlc_bifunc">ISFIELD</span>(FixPtUtils,utilityName))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% register that utility is being defined</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> tmpRet = <span class="tlc_bifunc">SETFIELD</span>(FixPtUtils,utilityName,1)
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPushEmptyStackSharedUtils">LibPushEmptyStackSharedUtils</a>()</span>>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility header comments</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%  Produce header comment for utility</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> fcnAbstract 
 <br>Time delay interpolation routine
 <br>&nbsp; <br>The linear interpolation is performed using the formula:
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t2 - tMinusDelay)         (tMinusDelay - t1)
 <br>u(t)  =  ----------------- * u1  +  ------------------- * u2
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(t2 - t1)                  (t2 - t1)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> fcnAbstract
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility definition</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% create first line of utility macro or function</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnName = "%<<span>utilityName</span>>"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnReturns = "real_T"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnParams = ["real_T     tMinusDelay,", "real_T     tStart,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T     *tBuf,", "real_T     *uBuf,", "int_T      bufSz,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T      *lastIdx,", "int_T      oldestIdx,", "int_T      newIdx,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T     initOutput,", "boolean_T  discrete,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"boolean_T  minorStepAndTAtLastMajorOutput"]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcDecRoot    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>fcnReturns</span>> %<<span>fcnName</span>>(
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[0]>           /* tMinusDelay = currentSimTime - delay */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[1]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[2]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[3]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[4]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[5]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[6]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[7]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[8]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[9]>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<fcnParams[10]>)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcDecRoot
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_createrecord">%createrecord</span> fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract fcnAbstract; Category "utility"; GeneratedBy "<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/blocks/tdelay_sup.html">tdelay_sup.tlc</a>"}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/mw/commonhdrlib.html#SLibDumpFunctionBanner">SLibDumpFunctionBanner</a>(fcnRec)>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_undef">%undef</span> fcnRec
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T i;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T yout, t1, t2, u1, u2;
 <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* If there is only one data point in the buffer, this data point must be
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* the t= 0 and tMinusDelay > t0, it ask for something unknown. The best
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* guess if initial output as well
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (newIdx == 0) &amp;&amp; (oldestIdx ==0 ) &amp;&amp; (tMinusDelay > tStart))  return initOutput;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* If tMinusDelay is less than zero, should output initial value
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tMinusDelay <= tStart) return initOutput;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* For fixed buffer extrapolation: 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* if tMinusDelay is small than the time at oldestIdx, if discrete, output
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* tailptr value,  else use tailptr and tailptr+1 value to extrapolate
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* It is also for fixed buffer. Note: The same condition can happen for transport delay block where 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* use tStart and and t[tail] other than using t[tail] and t[tail+1]. 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* See below
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (tMinusDelay <= tBuf[oldestIdx] ) ) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discrete){
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(uBuf[oldestIdx]);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T tempIdx=oldestIdx + 1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(oldestIdx == bufSz-1) tempIdx = 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1=tBuf[oldestIdx];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2=tBuf[tempIdx];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1=uBuf[oldestIdx];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u2=uBuf[tempIdx];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t2 == t1) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tMinusDelay >= t2) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = u2;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = u1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T f1 = (t2-tMinusDelay) / (t2-t1);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T f2 = 1.0 - f1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Use Lagrange's interpolation formula.  Exact outputs at t1, t2.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = f1*u1 + f2*u2;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return yout;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* When block does not have direct feedthrough, we use the table of
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* values to extrapolate off the end of the table for delays that are less
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* than 0 (less then step size).  This is not completely accurate.  The
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* chain of events is as follows for a given time t.  Major output - look 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* in table.  Update - add entry to table.  Now, if we call the output at 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* time t again, there is a new entry in the table. For very small delays,
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* this means that we will have a different answer from the previous call 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* to the output fcn at the same time t.  The following code prevents this 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* from happening.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (minorStepAndTAtLastMajorOutput) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* pretend that the new entry has not been added to table */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newIdx != 0) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (*lastIdx == newIdx) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*lastIdx)--;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIdx--;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (*lastIdx == newIdx) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*lastIdx = bufSz-1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newIdx = bufSz - 1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = *lastIdx;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tBuf[i] < tMinusDelay) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Look forward starting at last index */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (tBuf[i] < tMinusDelay) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* May occur if the delay is less than step-size - extrapolate */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i == newIdx) break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = ( i < (bufSz-1) ) ? (i+1) : 0; /* move through buffer */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Look backwards starting at last index which can happen when the
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* delay time increases.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while (tBuf[i] >= tMinusDelay) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Due to the entry condition at top of function, we
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* should never hit the end.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = (i > 0) ? i-1 : (bufSz-1); /* move through buffer */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i = ( i < (bufSz-1) ) ? (i+1) : 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*lastIdx = i;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discrete) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* tempEps = 128 * eps;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* localEps = max(tempEps, tempEps*fabs(tBuf[i]))/2;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double tempEps  = %<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/mathlib.html#LibGetMathConstant">LibGetMathConstant</a>("EPSILON",tSS_DOUBLE)> * 128.0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;double localEps = tempEps * %<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/mathlib.html#LibGenSharedMathFcnCall">LibGenSharedMathFcnCall</a>("abs",tSS_DOUBLE,"tBuf[i]","")>;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tempEps > localEps) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localEps = tempEps;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;localEps = localEps / 2.0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tMinusDelay >= (tBuf[i] - localEps)) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = uBuf[i];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i == 0) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = uBuf[bufSz-1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = uBuf[i-1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (i == 0) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1 = tBuf[bufSz-1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1 = uBuf[bufSz-1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t1 = tBuf[i-1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u1 = uBuf[i-1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t2 = tBuf[i];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;u2 = uBuf[i];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (t2 == t1) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tMinusDelay >= t2) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = u2;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = u1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T f1 = (t2-tMinusDelay) / (t2-t1);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T f2 = 1.0 - f1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Use Lagrange's interpolation formula.  Exact outputs at t1, t2.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yout = f1*u1 + f2*u2;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(yout); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish header comment</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish off utility define</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#SLibDumpUtilsSourceCodeAndCacheFunctionPrototype">SLibDumpUtilsSourceCodeAndCacheFunctionPrototype</a>(utilityName,funcProto,utilityDef)>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> GSUStackBuf = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPopStackSharedUtilsIncludes">LibPopStackSharedUtilsIncludes</a>()
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span>  <span class="tlc_comment">%% definition of utility</span>
 <br>&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/mathlib.html#FcnTrackSharedUtilHeaderFileUsage">FcnTrackSharedUtilHeaderFileUsage</a>(utilityName + ".h", TLC_FALSE)>
 <br>&nbsp;&nbsp;<span class="tlc_return">%return</span> utilityName
 <br><span class="tlc_fkw">%endfunction</span>  <span class="tlc_comment">%% TDelay_Interpolate</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Function:<span style="padding-left:9.5px"></span>rt_VTDelayfindtDInterpolate<span style="padding-left:9.5px"></span>==========================================
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_fkw">%function</span> <a id="VTDelay_FindtDInterpolate" class="tlc_func">VTDelay_FindtDInterpolate</a>(block) <span class="tlc_fkw">void</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/fixpt/fixptlib.html#FixPt_UtilityMakeName">FixPt_UtilityMakeName</a>("rt_VTDelayfindtDInterpolate")
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%% END: Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Register utility name in the Shared Code Manager</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#SLibRegisterSharedUtility">SLibRegisterSharedUtility</a>(block, utilityName)
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% determine if the required utility has already been defined</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%   If it has not, then create the definition.</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> !(<span class="tlc_bifunc">ISFIELD</span>(FixPtUtils,utilityName))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% register that utility is being defined</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> tmpRet = <span class="tlc_bifunc">SETFIELD</span>(FixPtUtils,utilityName,1)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPushEmptyStackSharedUtils">LibPushEmptyStackSharedUtils</a>()</span>>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%  Produce header comment for utility</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnAbstract = "For variable transport delay block, find the real delay time"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility definition</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% create first line of utility macro or function</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnName = "%<<span>utilityName</span>>"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnParams = [ ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T        x,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T*       tBuf,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T*       uBuf,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T*       xBuf,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T         bufSz,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T         head,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T         tail,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T*        pLast,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T        t,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T        tStart,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"boolean_T     discrete,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"boolean_T     minorStepAndTAtLastMajorOutput,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T        initOutput,",  ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T*       appliedDelay"]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnReturns = "real_T"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> funcDecRoot = fcnReturns + " " + utilityName + "(/n"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_foreach">%foreach</span> idx = <span class="tlc_bifunc">SIZE</span>(fcnParams, 1)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> funcDecRoot = funcDecRoot + fcnParams[idx]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endforeach">%endforeach</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> funcDecRoot = funcDecRoot + ")"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%   </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_createrecord">%createrecord</span> fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract fcnAbstract; Category "utility"; GeneratedBy "<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/blocks/tdelay_sup.html">tdelay_sup.tlc</a>"}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/mw/commonhdrlib.html#SLibDumpFunctionBanner">SLibDumpFunctionBanner</a>(fcnRec)>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_undef">%undef</span> fcnRec
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T n, k;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T f;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T kp1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T tminustD, tL, tR, uD, uL, uR, fU;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (minorStepAndTAtLastMajorOutput) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* pretend that the entry at head has not been added */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (*pLast == head) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pLast = (*pLast == 0) ? bufSz-1 : *pLast-1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;head = (head == 0) ? bufSz-1 : head-1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* The loop below finds k such that:
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*      x(t)-x(tminustD) =1 or
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*      x - xBuf[k+1] <= 1.0 < x - xBuf[k]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* Note that we have:
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* tStart = tBuf[0] < tBuf[1] < ... < tBuf[tail] < ... tBuf[head] <= t
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*      0 = xBuf[0] < xBuf[1] < ... < xBuf[tail] < ... xBuf[head] <  x
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* This is true if we assume the direction of transport is always positive
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* such as a flow goes through a pipe from one end to another. However, for
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* model such as convey belt, the transportation can change direction. For
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* this case, there will be more than one solution to x(t)-x(tminustD) = 1,
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* should found the minimum tminustD and tminustD > 0. The search will not
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* be as efficient as the following code.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* when x<=1, physically it means the flow didn't reach the output yet, 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* t-tD will be less then zero, so force output to be the initial output
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x <= 1)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return initOutput; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* if the x is monoton increase, only one solution. use k=pLast for now
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k=*pLast;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(;;) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n++;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(n>bufSz)break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x - xBuf[k] > 1.0) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* move k forward, unless k = head */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (k == head) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* xxx this situation means tD= appliedDelay = 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* linearly interpolate using (tBuf[head], xBuf[head])
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* and (t,x) to find (tD,xD) such that: x - xD = 1.0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T km1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = (x - 1.0 - xBuf[k]) / (x - xBuf[k]);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tminustD = (1.0-f)*tBuf[k] + f*t;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;km1 = k-1; if (km1 < 0) km1 = bufSz-1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tL = tBuf[km1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tR = tBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uL = uBuf[km1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uR = uBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kp1 = k+1; if (kp1 == bufSz) kp1 = 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (x - xBuf[kp1] <= 1.0){
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* linearly interpolate using (tBuf[k], xBuf[k])
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* and  (tBuf[k+1], xBuf[k+1]) to find (tminustD,xD)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* such that: x - xD = 1.0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = (x - 1.0 - xBuf[k]) / (xBuf[kp1] - xBuf[k]);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tL = tBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tR = tBuf[kp1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uL = uBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uR = uBuf[kp1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tminustD = (1.0-f)*tL + f*tR;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = kp1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* moved k backward, unless k = tail */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (k == tail) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* This situation means tminustD <= Ttail*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f = (x - 1.0)/xBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discrete){
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(uBuf[tail]);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;kp1 = k+1; if (kp1 == bufSz) kp1 = 0;               
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* * linearly interpolate using (tStart, 0)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* and  (tBuf[tail], xBuf[tail]) to find (tminustD,xD)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* such that: x - xD = 1.0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Here it is better to use Tstart because since x>1, tminustD
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* must > 0. Since x is monotone increase, its linearity is 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* better. 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tminustD = (1-f)*tStart + f*tBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* linearly interpolate using (t[tail], x[tail])
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* and  (tBuf[tail+1], xBuf[tail+1]) to find (tminustD,xD)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* such that: x - xD = 1.0. 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* For time delay block, use t[tail] and t[tail+1], not good
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* for transport delay block since it may give tminstD < 0
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*  f = (tBuf[kp1]-tBuf[k])/(xBuf[kp1]-xBuf[k]);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*  tminustD = tBuf[kp1]-f*(1+xBuf[kp1]-x);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tL = tBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tR = tBuf[kp1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uL = uBuf[k];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uR = uBuf[kp1];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k = k - 1; if (k < 0)  k = bufSz-1;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*pLast = k;     
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(tR == tL) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fU =1.0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fU = (tminustD-tL)/(tR-tL);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* for discrete signal, no interpolation, use either uL or uR
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* depend on wehre tminustD is.
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (discrete) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uD= (fU > (1.0-fU))? uR: uL;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;uD = (1.0-fU)*uL + fU*uR;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* we want return tD= t-(t-tD);*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*appliedDelay = t-tminustD; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return uD; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish header comment</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish off utility define</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#SLibDumpUtilsSourceCodeAndCacheFunctionPrototype">SLibDumpUtilsSourceCodeAndCacheFunctionPrototype</a>(utilityName,funcProto,utilityDef)>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> GSUStackBuf = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPopStackSharedUtilsIncludes">LibPopStackSharedUtilsIncludes</a>()
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span>  <span class="tlc_comment">%% definition of utility</span>
 <br>&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/mathlib.html#FcnTrackSharedUtilHeaderFileUsage">FcnTrackSharedUtilHeaderFileUsage</a>(utilityName + ".h", TLC_FALSE)>
 <br>&nbsp;&nbsp;<span class="tlc_return">%return</span> utilityName
 <br><span class="tlc_fkw">%endfunction</span>  <span class="tlc_comment">%% VTDelay_FindtDInterpolate</span>
 <br>&nbsp; <br>&nbsp; <br>&nbsp; <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Function:<span style="padding-left:9.5px"></span>TDelay_UpdateTailOrGrowBuf<span style="padding-left:9.5px"></span>==========================================
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_fkw">%function</span> <a id="TDelay_UpdateTailOrGrowBuf" class="tlc_func">TDelay_UpdateTailOrGrowBuf</a>(block) <span class="tlc_fkw">void</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/fixpt/fixptlib.html#FixPt_UtilityMakeName">FixPt_UtilityMakeName</a>("rt_TDelayUpdateTailOrGrowBuf")
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%% END: Create a string to represent the utility</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% Register utility name in the Shared Code Manager</span>
 <br>&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#SLibRegisterSharedUtility">SLibRegisterSharedUtility</a>(block, utilityName)
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;<span class="tlc_comment">%% determine if the required utility has already been defined</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%   If it has not, then create the definition.</span>
 <br>&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> !(<span class="tlc_bifunc">ISFIELD</span>(FixPtUtils,utilityName))
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% register that utility is being defined</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> tmpRet = <span class="tlc_bifunc">SETFIELD</span>(FixPtUtils,utilityName,1)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPushEmptyStackSharedUtils">LibPushEmptyStackSharedUtils</a>()</span>>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> tmpBuf
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> (isRSim || Accelerator)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifndef __RTW_UTFREE__  <span class="tlc_comment">%% defined in rtw/c/src/rtw_modelmap.h   </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;extern "C" {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#LibExternInFcnDecls">LibExternInFcnDecls</a>()</span>>void * utMalloc(size_t);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span><a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#LibExternInFcnDecls">LibExternInFcnDecls</a>()</span>>void   utFree(void *); 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_if">%if</span> ::GenCPP
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#ifdef __cplusplus
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#endif
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endif">%endif</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> tmpBuf
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%  Produce header comment for utility</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnAbstract = "Buffer management routine for variable delay block"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% open a buffer to hold the utility definition</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% create first line of utility macro or function</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnName = "%<<span>utilityName</span>>"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnReturns = "boolean_T"
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> fcnParams = [ ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T       *bufSzPtr,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T       *tailPtr,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T       *headPtr,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T       *lastPtr,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T      tMinusDelay,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T      **tBufPtr,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T      **uBufPtr,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"real_T      **xBufPtr,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"boolean_T   isfixedbuf,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"boolean_T istransportdelay,", ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"int_T     *maxNewBufSzPtr"]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> funcDecRoot = ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnReturns + "  " + fcnName +"(/n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[0] + "        /* in/out - circular buffer size                 *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[1] + "         /* in/out - tail of circular buffer              *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[2] + "         /* in/out - head of circular buffer              *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[3] + "         /* in/out - same logical 'last' referenced index *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[4] + "      /* in     - last point we are looking at   *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[5] + "        /* in/out - larger buffer for time         *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[6] + "        /* in/out - larger buffer for input        *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[7] + "        /* in/out - larger buffer for state        *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[8] + "       /* in     - fixed buffer size enable       *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[9] + "   /* in     - block acts as transport dela y *//n" + ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fcnParams[10] + ")" 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_openfile">%openfile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> funcProto
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_createrecord">%createrecord</span> fcnRec {Name fcnName; Returns fcnReturns; Params fcnParams; ...
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstract fcnAbstract; Category "utility"; GeneratedBy "<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/blocks/tdelay_sup.html">tdelay_sup.tlc</a>"}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/mw/commonhdrlib.html#SLibDumpFunctionBanner">SLibDumpFunctionBanner</a>(fcnRec)>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_undef">%undef</span> fcnRec
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<span>funcDecRoot</span>>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> nulldef = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/utillib.html#SLibGetNullDefinitionFromTfl">SLibGetNullDefinitionFromTfl</a>()
 <br>&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T  testIdx;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T  tail  = *tailPtr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T  bufSz = *bufSzPtr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T *tBuf = *tBufPtr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T *xBuf = %<<span>nulldef</span>>; 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T    numBuffer = 2;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (istransportdelay){
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numBuffer =3 ;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xBuf= *xBufPtr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*    Get testIdx, the index of the second oldest data point and
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*    see if this is older than current sim time minus applied delay,
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*    used to see if we can move tail forward 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testIdx = (tail < (bufSz - 1)) ? (tail + 1) : 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if ( (tMinusDelay <= tBuf[testIdx]) &amp;&amp; !isfixedbuf) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T  j;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T *tempT;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T *tempU;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T *tempX = %<<span>nulldef</span>>;    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;real_T *uBuf     = *uBufPtr;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int_T  newBufSz  = bufSz + 1024;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (newBufSz > *maxNewBufSzPtr) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*maxNewBufSzPtr = newBufSz; /* save for warning*/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempU = (real_T*)utMalloc(numBuffer*newBufSz*sizeof(real_T));        
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (tempU == %<<span>nulldef</span>>){
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (%<GET_TYPE_ID_REPLACEMENT("false")>);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}     
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempT = tempU + newBufSz;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(istransportdelay) tempX = tempT + newBufSz;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j = tail; j < bufSz; j++) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempT[j - tail] = tBuf[j];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempU[j - tail] = uBuf[j];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (istransportdelay)  
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempX[j - tail] = xBuf[j];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (j = 0; j < tail; j++) {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempT[j + bufSz - tail] = tBuf[j];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempU[j + bufSz - tail] = uBuf[j];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (istransportdelay)  
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tempX[j + bufSz - tail] = xBuf[j];
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (*lastPtr> tail) 
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*lastPtr -= tail;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*lastPtr += (bufSz - tail);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*tailPtr= 0;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*headPtr = bufSz;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;utFree(uBuf);
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*bufSzPtr = newBufSz;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*tBufPtr  = tempT;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*uBufPtr  = tempU;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (istransportdelay) *xBufPtr  = tempX;
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else {
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*tailPtr = testIdx; /* move tail forward */
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return(%<GET_TYPE_ID_REPLACEMENT("true")>);      
 <br>&nbsp; <br>&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% finish off utility define</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_selectfile">%selectfile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;}
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_closefile">%closefile</span> utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% cause utility define to be included in generated code</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilityDef = tmpBuf + utilityDef
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#SLibDumpUtilsSourceCodeAndCacheFunctionPrototype">SLibDumpUtilsSourceCodeAndCacheFunctionPrototype</a>(utilityName,funcProto,utilityDef)>/
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> GSUStackBuf = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/cache_sharedutils_lib.html#LibPopStackSharedUtilsIncludes">LibPopStackSharedUtilsIncludes</a>()
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span>  <span class="tlc_comment">%% definition of utility</span>
 <br>&nbsp;&nbsp;%<<a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/mathlib.html#FcnTrackSharedUtilHeaderFileUsage">FcnTrackSharedUtilHeaderFileUsage</a>(utilityName + ".h", TLC_FALSE)>
 <br>&nbsp;&nbsp;<span class="tlc_return">%return</span> utilityName
 <br><span class="tlc_fkw">%endfunction</span>  <span class="tlc_comment">%% TDelay_Interpolate</span>
 <br>&nbsp; <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Function:<span style="padding-left:9.5px"></span>TDelay_Terminate<span style="padding-left:9.5px"></span>========================================================
</span> <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span>Abstract:
</span> <br><span class="tlc_comment">%%<span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span><span style="padding-left:9.5px"></span>Free<span style="padding-left:9.5px"></span>PWorks<span style="padding-left:9.5px"></span>used<span style="padding-left:9.5px"></span>with<span style="padding-left:9.5px"></span>RSim<span style="padding-left:9.5px"></span>target
</span> <br><span class="tlc_comment">%%
</span> <br><span class="tlc_fkw">%function</span> <a id="TDelay_Terminate" class="tlc_func">TDelay_Terminate</a>(block, system) <span class="tlc_fkw">Output</span>
 <br>&nbsp;&nbsp;<span class="tlc_if">%if</span> isRSim
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> localRollThreshold = 2
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> rollVars = ["<pwork>/TUbufferPtrs"]
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_roll">%roll</span> idx = RollRegions, lcv = localRollThreshold, block, "Roller", rollVars      
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> pUbuf = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/lib/blocklib.html#LibBlockPWork">LibBlockPWork</a>(TUbufferPtrs, "", lcv, idx)    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%%</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% first call unitility to generate rt_TDelayCreateBuf</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% This is called instead of utFree() in order to avoid Windows-specific </span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_comment">%% crash due to mallocing and freeing in different libs.</span>
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_assign">%assign</span> utilName = <a href="https://foool.github.io/MATLAB/R2020a/rtw/c/tlc/blocks/tdelay_sup.html#TDelay_FreeBuf">TDelay_FreeBuf</a>(block)
 <br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;%<<span>utilName</span>>(%<<span>pUbuf</span>>);    
 <br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="tlc_endroll">%endroll</span>
 <br>&nbsp;&nbsp;<span class="tlc_endif">%endif</span> <span class="tlc_comment">%% end of RSim section</span>
 <br>&nbsp;&nbsp;&nbsp; <br><span class="tlc_fkw">%endfunction</span> <span class="tlc_comment">%% TDelay_Terminate</span>
 <br></body></html>